/// Build script that generates:
/// 1. `vrf_constants.rs` – VRF program addresses from env vars
/// 2. `discriminators.rs` – precomputed Anchor-compatible 8-byte discriminators
///
/// When `VRF_PROGRAM_ID`, `VRF_QUEUE_ID`, or `VRF_IDENTITY_ID` env vars are
/// set (in base58), those values are compiled into the binary.  Otherwise the
/// mainnet Switchboard defaults are used.
///
/// Usage (optional – only needed for devnet/localnet overrides):
///   VRF_PROGRAM_ID=<base58> VRF_QUEUE_ID=<base58> VRF_IDENTITY_ID=<base58> \
///     cargo build-sbf
use sha2::{Digest, Sha256};
use std::{env, fs, path::PathBuf};

const DEFAULT_VRF_PROGRAM_ID: &str = "Vrf1RNUjXmQGjmQrQLvJHs9SNkvDJEsRVFPkfSQUwGz";
const DEFAULT_VRF_QUEUE_ID: &str = "Cuj97ggrhhidhbu39TijNVqE74xvKJ69gDervRUXAxGh";
const DEFAULT_VRF_IDENTITY_ID: &str = "9irBy75QS2BN81FUgXuHcjqceJJRuc9oDkAe8TKVvvAw";

fn decode_bs58(name: &str, val: &str) -> [u8; 32] {
    let bytes = bs58::decode(val)
        .into_vec()
        .unwrap_or_else(|e| panic!("{name}={val} is not valid base58: {e}"));
    <[u8; 32]>::try_from(bytes.as_slice())
        .unwrap_or_else(|_| panic!("{name}={val} decoded to {} bytes, expected 32", bytes.len()))
}

fn format_bytes32(arr: &[u8; 32]) -> String {
    let inner: Vec<String> = arr.iter().map(|b| format!("{b}")).collect();
    format!("[{}]", inner.join(", "))
}

/// Compute Anchor-compatible discriminator: sha256("{namespace}:{name}")[..8]
fn anchor_discriminator(namespace: &str, name: &str) -> [u8; 8] {
    let mut hasher = Sha256::new();
    hasher.update(namespace.as_bytes());
    hasher.update(b":");
    hasher.update(name.as_bytes());
    let digest = hasher.finalize();
    let mut out = [0u8; 8];
    out.copy_from_slice(&digest[..8]);
    out
}

fn format_disc(arr: &[u8; 8]) -> String {
    let inner: Vec<String> = arr.iter().map(|b| format!("0x{b:02x}")).collect();
    format!("[{}]", inner.join(", "))
}

fn to_screaming_snake(name: &str) -> String {
    name.to_uppercase()
}

fn generate_vrf_constants(out_dir: &PathBuf) {
    let vrf_program = env::var("VRF_PROGRAM_ID").unwrap_or(DEFAULT_VRF_PROGRAM_ID.to_string());
    let vrf_queue = env::var("VRF_QUEUE_ID").unwrap_or(DEFAULT_VRF_QUEUE_ID.to_string());
    let vrf_identity = env::var("VRF_IDENTITY_ID").unwrap_or(DEFAULT_VRF_IDENTITY_ID.to_string());

    let vrf_program_bytes = decode_bs58("VRF_PROGRAM_ID", &vrf_program);
    let vrf_queue_bytes = decode_bs58("VRF_QUEUE_ID", &vrf_queue);
    let vrf_identity_bytes = decode_bs58("VRF_IDENTITY_ID", &vrf_identity);

    let out = format!(
        r#"// Auto-generated by build.rs – do not edit.
// Override via env vars: VRF_PROGRAM_ID, VRF_QUEUE_ID, VRF_IDENTITY_ID (base58).

use pinocchio::Address;

pub const VRF_PROGRAM_ID: Address = Address::new_from_array({});
pub const DEFAULT_QUEUE: Address = Address::new_from_array({});
pub const VRF_PROGRAM_IDENTITY: Address = Address::new_from_array({});
"#,
        format_bytes32(&vrf_program_bytes),
        format_bytes32(&vrf_queue_bytes),
        format_bytes32(&vrf_identity_bytes),
    );

    let dest = out_dir.join("vrf_constants.rs");
    fs::write(&dest, out).expect("failed to write vrf_constants.rs");
}

fn generate_discriminators(out_dir: &PathBuf) {
    // All 23 instruction names (namespace "global")
    let ix_names: &[&str] = &[
        "upsert_degen_config",
        "init_config",
        "update_config",
        "transfer_admin",
        "set_treasury_usdc_ata",
        "lock_round",
        "start_round",
        "admin_force_cancel",
        "deposit_any",
        "cancel_round",
        "claim_refund",
        "claim",
        "auto_claim",
        "close_participant",
        "close_round",
        "request_vrf",
        "vrf_callback",
        "request_degen_vrf",
        "degen_vrf_callback",
        "begin_degen_execution",
        "claim_degen_fallback",
        "claim_degen",
        "finalize_degen_success",
    ];

    // All 5 account names (namespace "account")
    let acct_names: &[&str] = &[
        "Config",
        "Round",
        "Participant",
        "DegenClaim",
        "DegenConfig",
    ];

    let mut code = String::from(
        "// Auto-generated by build.rs – do not edit.\n\
         // Precomputed Anchor-compatible discriminators: sha256(\"{namespace}:{name}\")[..8]\n\n",
    );

    code.push_str("// ── Instruction discriminators (namespace: \"global\") ──\n");
    for name in ix_names {
        let disc = anchor_discriminator("global", name);
        let const_name = format!("IX_{}", to_screaming_snake(name));
        code.push_str(&format!(
            "pub const {}: [u8; 8] = {};\n",
            const_name,
            format_disc(&disc),
        ));
    }

    code.push_str("\n// ── Account discriminators (namespace: \"account\") ──\n");
    for name in acct_names {
        let disc = anchor_discriminator("account", name);
        let const_name = format!("ACCT_{}", to_screaming_snake(name));
        code.push_str(&format!(
            "pub const {}: [u8; 8] = {};\n",
            const_name,
            format_disc(&disc),
        ));
    }

    let dest = out_dir.join("discriminators.rs");
    fs::write(&dest, code).expect("failed to write discriminators.rs");
}

fn main() {
    let out_dir: PathBuf = env::var("OUT_DIR").expect("OUT_DIR not set").into();

    generate_vrf_constants(&out_dir);
    generate_discriminators(&out_dir);

    // Re-run build.rs if env vars change.
    println!("cargo:rerun-if-env-changed=VRF_PROGRAM_ID");
    println!("cargo:rerun-if-env-changed=VRF_QUEUE_ID");
    println!("cargo:rerun-if-env-changed=VRF_IDENTITY_ID");
}
